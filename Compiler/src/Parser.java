import java.util.ArrayList;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

/**
 * Parser for GILLES.
 * 
 * The parser implements a recursive descent mimicking the run of the pushdown automaton: the call stack replacing the automaton stack.
 * 
 * @author Aya IFTISSEN, Eurielle Nkwinga
 *
 */
public class Parser{
    /**
     * Lexer object for the parsed file.
     */
    private LexicalAnalyzer scanner;
    /**
     * Current symbol at the head of the word to be read. This corresponds to the look-ahead (of length 1).
     */
    private Symbol current;
 /**
     * String containing the functions needed for the program to run.
     * like INPUT() and OUTPUT().
     */
    private String addedFunctions = "";
    /**
     * Boolean to know if the input() function was already added to the program.
     */
    private Boolean inputAdded = false;
    /**
     * Boolean to know if the output() function was already added to the program.
     */
    private Boolean outputAdded = false;
  
    /**
     * List of the variables declared in the program.
     */
    private ArrayList<String> varList = new ArrayList<String>();
    /**
     * String containing the variables added to the program.
     * Used to allocate memory for the variables at the beginning of the program.
     */
    private String addedVariables = "";
    /**
     * Number of the line in the LLVM code. i.e. #0, #1, #2, ...
     */
    private int lineNumber = 0;
    /**
     * Number of the if label in the LLVM code. i.e. if0, if1, if2, ...
     */
    private int ifNumber = 0;
    /**
     * Number of the while label in the LLVM code. i.e. while0, while1, while2, ...
     */
    private int whileNumber = 0;
     /**
     * Number of the for label in the LLVM code. i.e. for0, for1, for2, ...
     */
    private int forNumber = 0;
    


    /**
     * Creates a Parser object for the provided file and initialized the look-ahead.
     * 
     * @param source a FileReader object for the parsed file.
     * @throws IOException in case the lexing fails (syntax error).
     */
    public Parser(FileReader source) throws IOException{
        this.scanner = new LexicalAnalyzer(source);
        this.current = scanner.nextToken();
    }
        

    /* Matching of terminals */
    /**
     * Advances in the input stream, consuming one token.
     * 
     * @throws IOException in case the lexing fails (syntax error).
     */
    private void consume() throws IOException{
        current = scanner.nextToken();
    }

     /**
     * Matches a (terminal) token from the head of the word.
     * 
     * @param token then LexicalUnit (terminal) to be matched.
     * @throws IOException in case the lexing fails (syntax error).
     * @throws ParseException in case the matching fails (syntax error): the next token is not the one to be matched.
     */
    private void match(LexicalUnit token) throws IOException, ParseException{
        if(!current.getType().equals(token)){
            // There is a parsing error
            throw new ParseException(current, Arrays.asList(token));
           
        }
        else {
            //Symbol cur = current;
            consume();
            return;
        }
    }

    /* Applying grammar rules */
    /**
     * Parses the file.
     * 
     * @return The LLVM code generated by the parser.
     * @throws IOException in case the lexing fails (syntax error).
     * @throws ParseException in case the parsing fails (syntax error).
     */
    public String parse() throws IOException, ParseException{
        // Program is the initial symbol of the grammar
        // The function program() returns a string containing the LLVM code generated by the parser
        String llvm = program();
        return llvm;
    }

   
    /* Adding functions and variables to the llvm code */
    /**
     * Adds the input() function to the program.
     */
    private void addinput(){
        if(this.inputAdded){return;}
        String declareInput =  "@.strR = private unnamed_addr constant [3 x i8] c\"%d\\00\", align 1\n\n"
                            + "; Function Attrs: noinline nounwind optnone ssp uwtable\n"
                            + "define i32 @input() #0 {\n"
                            + "  %1 = alloca i32, align 4\n"
                            + "  %2 = call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.strR, i32 0, i32 0), i32* %1)\n"
                            + "  %3 = load i32, i32* %1, align 4\n"
                            + "  ret i32 %3\n"
                            + "}\n\n"
                            + "declare i32 @scanf(i8*, ...) #1\n\n";
        this.addedFunctions += declareInput;
        this.inputAdded = true;
        return;
    }

    /**
     * Adds the output() function to the program.
     */
    private void addoutput(){
        if(this.outputAdded){return;}
        String declareOutput = "@.strP = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\", align 1\n\n"
                            + "; Function Attrs: nounwind uwtable\n"
                            + "define void @output(i32 %x) #0 {\n"
                            + "  %1 = alloca i32, align 4\n"
                            + "  store i32 %x, i32* %1, align 4\n"
                            + "  %2 = load i32, i32* %1, align 4\n"
                            + "  %3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.strP, i32 0, i32 0), i32 %2)\n"
                            + "  ret void\n"
                            + "}\n\n"
                            + "declare i32 @printf(i8*, ...) #1\n\n";
        this.addedFunctions += declareOutput;
        this.outputAdded = true;
        return;
    }


    /**
     * Adds a variable to the list of variables.
     * 
     * @param varName the name of the variable to be added.
     */
    private void addVariable(String varName, LexicalUnit type){
        if(this.varList.contains(varName)){return;}
        this.varList.add(varName);
        if(type.equals(LexicalUnit.NUMBER)){
            this.addedVariables += "  %"+varName+" = alloca i32\n";
            return;
        }else if(type.equals(LexicalUnit.VARNAME)){
            this.addedVariables += "  %"+varName+" = alloca i32\n";
            return;
        }
        return;
    }
    
  /**
 * Parses and generates LLVM IR code for the <Program> non-terminal 
 * in the grammar. This is the entry point for parsing and code 
 * generation, and it processes the entire program structure.
 * 
 * @return A String containing the complete LLVM IR code for the program.
 * @throws IOException If there is an error during lexical analysis (e.g., input reading).
 * @throws ParseException If there is a syntax error during parsing.
 */
private String program() throws IOException, ParseException {
        // [1] <Program>  ->  LET [ProgName] BE <Code> END
            match(LexicalUnit.LET);
            match(LexicalUnit.PROGNAME);
            match(LexicalUnit.BE);
            String code = code();
            String program = "define i32 @Program() {\n"
                        + " entry:\n"
                        + this.addedVariables
                        + code
                        + "  ret i32 0\n"
                        + "}\n\n";
        String main = "define i32 @main() {\n"
                    + " entry:\n"
                    + "  %calltmp = call i32 @Program()\n"
                    + "  ret i32 %calltmp\n"
                    + "}\n";
            match(LexicalUnit.END);
            return this.addedFunctions + program + main;
       
    }
    /**
     * 
     * @return a String containing the LLVM code.
     * @throws IOException in case the lexing fails (syntax error).
     * @throws ParseException in case the parsing fails (syntax error).
     */
    
    private String code() throws IOException, ParseException{
        switch(current.getType()) {
            // [2] <Code>  ->  <Instruction>:<Code>
            case IF:
            case WHILE:
            case FOR:
            case OUTPUT:
            case INPUT:
            case VARNAME: 
                 String instr = instruction();
                 match(LexicalUnit.COLUMN);
                 String code = code();
                 return instr + code;
            // [3] <Code>  ->  EPSILON 
            case END:
            case ELSE:
               return " " ;
            default:
                throw new ParseException(current,NonTerminal.Code,Arrays.asList(
                    LexicalUnit.IF,
                    LexicalUnit.ELSE,
                    LexicalUnit.WHILE,
                    LexicalUnit.FOR,
                    LexicalUnit.OUTPUT,
                    LexicalUnit.INPUT,
                    LexicalUnit.VARNAME,
                    LexicalUnit.END
                ));
        }
    }
/**
 * Handles an <Instruction> at the top of the stack.
 * 
 * Tries to apply one of the following rules:
 * 
 * 1. <Instruction> → <Assign>
 * 2. <Instruction> → <If>
 * 3. <Instruction> → <While>
 * 4. <Instruction> → <Output>
 * 5. <Instruction> → <Input>
 * 
 * @return a ParseTree with an <Instruction> non-terminal at the root.
 * @throws IOException if there is a lexing error (syntax error).
 * @throws ParseException if there is a parsing error (syntax error).
 */
private String instruction() throws IOException, ParseException {
    switch(current.getType()) {
        // <Instruction> → <Assign>
        case VARNAME:
            return assignExpr();
                
        // <Instruction> → <If>
        case IF:
            return ifExpr();

        // <Instruction> → <While>
        case WHILE:  
            return whileExpr();

        // <Instruction> → <For>
        case FOR:
            return forExpr();

        // <Instruction> → <Output>
        case OUTPUT:
            return outputExpr();

        // <Instruction> → <Input>
        case INPUT:
            return inputExpr();
            
        default:
            throw new ParseException(current, NonTerminal.Instruction, Arrays.asList(
                LexicalUnit.VARNAME,
                LexicalUnit.IF,
                LexicalUnit.WHILE,
                LexicalUnit.FOR,
                LexicalUnit.OUTPUT,
                LexicalUnit.INPUT
            ));
    }
}
/**
 * Handles an <Assign> at the top of the stack.
 * 
 * Tries to apply the rule:
 * <Assign> → [Varname] := <ExprArith>
 * 
 * @return a String with an <Assign> non-terminal at the root.
 * @throws IOException if there is a lexing error (syntax error).
 * @throws ParseException if there is a parsing error (syntax error).
 */
private String assignExpr() throws IOException, ParseException {
    switch (current.getType()) {
        case VARNAME:
            // <Assign> → [Varname] := <ExprArith>
            String varName = (String) current.getValue();
            match(LexicalUnit.VARNAME);
            match(LexicalUnit.ASSIGN);
            String code = "";
            String expr = exprArith();
            addVariable(varName, LexicalUnit.VARNAME);
            code += expr;
            code += "  store i32 %" + (this.lineNumber - 1) + ", i32* %" + varName + "\n";
            return code;
            
        default:
            throw new ParseException(current, NonTerminal.Instruction, Arrays.asList(
                LexicalUnit.VARNAME
            ));
    }
}

   
    /**
 * Handles an <ExprArith> at the top of the stack.
 * 
 * Tries to apply the rule:
 * <ExprArith> → <Prod> <ExprArith'>
 * 
 * @return a String with an <ExprArith> non-terminal at the root.
 * @throws IOException if there is a lexing error (syntax error).
 * @throws ParseException if there is a parsing error (syntax error).
 */
private String exprArith() throws IOException, ParseException {
    switch (current.getType()) {
        case MINUS:
        case LPAREN:
        case VARNAME:
        case NUMBER:
            // <ExprArith> → <Prod> <ExprArith'>
            return prod() + exprArithPrime();
        default:
            throw new ParseException(current, NonTerminal.ExprArith, Arrays.asList(
                LexicalUnit.MINUS,
                LexicalUnit.LPAREN,
                LexicalUnit.VARNAME,
                LexicalUnit.NUMBER
            ));
    }
}

/**
 * Handles an <ExprArith'> at the top of the stack.
 * 
 * Tries to apply one of the following rules:
 * 1. <ExprArith'> → + <Prod> <ExprArith'>
 * 2. <ExprArith'> → - <Prod> <ExprArith'>
 * 3. <ExprArith'> → ε (epsilon)
 * 
 * @return a String with an <ExprArith'> non-terminal at the root.
 * @throws IOException if there is a lexing error (syntax error).
 * @throws ParseException if there is a parsing error (syntax error).
 */
private String exprArithPrime() throws IOException, ParseException {
    switch (current.getType()) {
        // <ExprArith'> → + <Prod> <ExprArith'>
        case PLUS:
            int nbrLastExp = this.lineNumber - 1;
            match(LexicalUnit.PLUS);
            String code = prod() + exprArithPrime();
            code += "  %" + this.lineNumber + " = add i32 %" + nbrLastExp + ", %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++;
            return code;
                
        // <ExprArith'> → - <Prod> <ExprArith'>
        case MINUS:
            nbrLastExp = this.lineNumber - 1;
            match(LexicalUnit.MINUS);
            code = prod() + exprArithPrime();
            code += "  %" + this.lineNumber + " = sub i32 %" + nbrLastExp + ", %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++;
            return code;
             
        // <ExprArith'> → ε (epsilon)
        case COLUMN:
        case RPAREN:
        case RBRACK:
        case EQUAL:
        case SMALEQ:
        case SMALLER:
        case IMPLIES:
        case PIPE:
            return "";
            
        default:
            throw new ParseException(current, NonTerminal.ExprArithPrime, Arrays.asList(
                LexicalUnit.PLUS,
                LexicalUnit.MINUS,
                LexicalUnit.COLUMN,
                LexicalUnit.RPAREN,
                LexicalUnit.RBRACK,
                LexicalUnit.EQUAL,
                LexicalUnit.SMALEQ,
                LexicalUnit.SMALLER,
                LexicalUnit.IMPLIES,
                LexicalUnit.PIPE
            ));
    }
}
/**
 * Handles a <Prod> at the top of the stack.
 * 
 * Tries to apply the rule:
 * <Prod> → <Atom> <Prod'>
 * 
 * @return a String with a <Prod> non-terminal at the root.
 * @throws IOException if there is a lexing error (syntax error).
 * @throws ParseException if there is a parsing error (syntax error).
 */
private String prod() throws IOException, ParseException {
    switch (current.getType()) {
        case MINUS:
        case LPAREN:
        case VARNAME:
        case NUMBER:
            // <Prod> → <Atom> <Prod'>
            return atom() + prodPrime();
        default:
            throw new ParseException(current, NonTerminal.ExprArith, Arrays.asList(
                LexicalUnit.MINUS,
                LexicalUnit.LPAREN,
                LexicalUnit.VARNAME,
                LexicalUnit.NUMBER
            ));
    }
}
/**
 * Handles a <Prod'> at the top of the stack.
 * 
 * Tries to apply one of the following rules:
 * <ul>
 *   <li>[19] <Prod'> → * <Atom> <Prod'</li>
 *   <li>[20] <Prod'> → / <Atom> <Prod'</li>
 *   <li>[21] <Prod'> → ε (epsilon, empty production)</li>
 * </ul>
 * 
 * @return a String with a <Prod'> non-terminal at the root.
 * @throws IOException if lexing fails (syntax error).
 * @throws ParseException if parsing fails (syntax error).
 */
private String prodPrime() throws IOException, ParseException {
    switch (current.getType()) {
        // [19] <Prod'> → * <Atom> <Prod'>
        case TIMES:
            int nbrLastExp = this.lineNumber - 1;
            match(LexicalUnit.TIMES);
            String code = atom() + prodPrime();
            code += "  %" + this.lineNumber + " = mul i32 %" + nbrLastExp + ", %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++; // Increment line number for next operation
            return code;
                
        // [20] <Prod'> → / <Atom> <Prod'>
        case DIVIDE:
            nbrLastExp = this.lineNumber - 1;
            match(LexicalUnit.DIVIDE);
            code = atom() + prodPrime();
            code += "  %" + this.lineNumber + " = sdiv i32 %" + nbrLastExp + ", %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++; // Increment line number for next operation
            return code;
                
        // [21] <Prod'> → ε (epsilon, empty production)
        case COLUMN:
        case PLUS:
        case MINUS:
        case RPAREN:
        case RBRACK:
        case EQUAL:
        case SMALLER:
        case SMALEQ:
        case IMPLIES:
        case PIPE:
            return ""; // No action, production ends here
                
        default:
            // Throws a ParseException if the current token doesn't match expected ones
            throw new ParseException(current, NonTerminal.ProdPrime, Arrays.asList(
                LexicalUnit.PLUS,
                LexicalUnit.MINUS,
                LexicalUnit.TIMES,
                LexicalUnit.DIVIDE,
                LexicalUnit.COLUMN,
                LexicalUnit.RPAREN,
                LexicalUnit.RBRACK,
                LexicalUnit.SMALEQ,
                LexicalUnit.IMPLIES,
                LexicalUnit.PIPE,
                LexicalUnit.EQUAL,
                LexicalUnit.SMALLER
            ));
    }
}


    /**
/**
 * Handles an <Atom> at the top of the stack.
 * 
 * Tries to apply one of the following rules:
 * <ul>
 *   <li>[18] <Atom> → [VarName]</li>
 *   <li>[19] <Atom> → [Number]</li>
 *   <li>[20] <Atom> → ( <ExprArith> )</li>
 *   <li>[21] <Atom> → - <Atom></li>
 * </ul>
 * 
 * @return a String with an <Atom> non-terminal at the root.
 * @throws IOException if lexing fails (syntax error).
 * @throws ParseException if parsing fails (syntax error).
 */
private String atom() throws IOException, ParseException {
    switch (current.getType()) {
        // [21] <Atom> → - <Atom>
        case MINUS:
            match(LexicalUnit.MINUS); // Consume the minus symbol
            String code = atom(); // Recursively handle the next atom
            // Generate LLVM IR for negating the atom (subtract from 0)
            code += "  %" + this.lineNumber + " = sub i32 0, %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++; // Increment the line number for the next operation
            return code;

        // [20] <Atom> → ( <ExprArith> )
        case LPAREN:
            match(LexicalUnit.LPAREN); // Consume the opening parenthesis
            code = exprArith(); // Parse the arithmetic expression inside the parentheses
            match(LexicalUnit.RPAREN); // Consume the closing parenthesis
            return code;

        // [18] <Atom> → [VarName]
        case VARNAME:
            String varName = (String) current.getValue(); // Get the variable name
            match(LexicalUnit.VARNAME); // Consume the variable name token
            // Check if the variable is declared before use
            if (!this.varList.contains(varName)) {
                throw new Error("Variable " + varName + " was not declared before use.");
            }
            this.lineNumber++;
            // Generate LLVM IR for loading the variable value
            return "  %" + (this.lineNumber - 1) + " = load i32, i32* %" + varName + "\n";

        // [19] <Atom> → [Number]
        case NUMBER:
            int nbr = (int) current.getValue(); // Get the number value
            match(LexicalUnit.NUMBER); // Consume the number token
            this.lineNumber++;
            // Generate LLVM IR for adding the number to zero
            return "  %" + (this.lineNumber - 1) + " = add i32 0, " + nbr + "\n";

        default:
            // If the token doesn't match any of the expected types, throw a ParseException
            throw new ParseException(current, NonTerminal.Atom, Arrays.asList(
                LexicalUnit.MINUS,
                LexicalUnit.LPAREN,
                LexicalUnit.VARNAME,
                LexicalUnit.NUMBER
            ));
    }
}

 /**
 * Handles the <If> expression at the top of the stack.
 * 
 * Tries to apply rule [22]:
 * <ul>
 *   <li>[22] <If> → IF { <Cond> } THEN <Code> <IfTail></li>
 * </ul>
 * 
 * @return a String representing the generated LLVM IR code for the <If> expression.
 * @throws IOException if lexing fails (syntax error).
 * @throws ParseException if parsing fails (syntax error).
 */
private String ifExpr() throws IOException, ParseException {
    // [22] <If> → IF { <Cond> } THEN <Code> <IfTail>
    String code = "";
    
    // Increment ifNumber to keep track of the unique label numbers for the "if" blocks
    this.ifNumber += 3;
    int currentIf = this.ifNumber;

    // Match the "if" keyword in the source code
    match(LexicalUnit.IF);

    // Match the opening curly brace for the condition
    match(LexicalUnit.LBRACK);

    // Get the condition part of the if expression
    String cond = cond();

    // Match the closing curly brace for the condition
    match(LexicalUnit.RBRACK);

    // Add the condition's generated LLVM IR to the overall code
    code += cond;

    // Generate the branch instruction for the if expression
    // The condition value will decide whether we jump to the "then" block or the "else" block
    code += "  br i1 %" + (this.lineNumber - 1) + ", label %if" + (currentIf - 3) + ", label %if" + (currentIf - 2) + "\n";

    // Match the "then" keyword
    match(LexicalUnit.THEN);

    // Get the code block to execute when the condition is true
    String thencode = code();

    // Parse the "else" block or continuation of the if expression (this may be empty in some cases)
    String ifTail = ifTail();

    // Add the "if" block (when condition is true) with its associated code
    code += " if" + (currentIf - 3) + ":\n";
    code += thencode;

    // After executing the "then" block, we jump to the common end point
    code += "  br label %if" + (currentIf - 1) + "\n";

    // Add the "else" block (if present)
    code += " if" + (currentIf - 2) + ":\n";
    code += ifTail;

    // After executing the "else" block, we jump to the common end point
    code += "  br label %if" + (currentIf - 1) + "\n";

    // This is the common end point after the if-else evaluation
    code += " if" + (currentIf - 1) + ":\n";

    return code;
}

/**
 * Handles the <IfTail> expression at the top of the stack.
 * 
 * Tries to apply one of the rules:
 * <ul>
 *   <li>[23] <IfTail> → END</li>
 *   <li>[24] <IfTail> → ELSE <Code> END</li>
 * </ul>
 * 
 * @return a String representing the generated LLVM IR code for the <IfTail> expression.
 * @throws IOException if lexing fails (syntax error).
 * @throws ParseException if parsing fails (syntax error).
 */
private String ifTail() throws IOException, ParseException {
    switch (current.getType()) {
        // [24] <IfTail> → ELSE <Code> END
        case ELSE:
            // Match the "ELSE" token
            match(LexicalUnit.ELSE);
            
            // Get the code block for the "else" part of the statement
            String elseCode = code();
            
            // Match the "END" token which marks the end of the if-else block
            match(LexicalUnit.END);
            
            // Return the generated code for the "else" block
            return elseCode;

        // [23] <IfTail> → END
        case END:
            // Match the "END" token, indicating the end of the if block
            match(LexicalUnit.END);
            
            // Return a blank string if there's no "else" part
            return " ";

        default:
            // If the current token doesn't match "END" or "ELSE", throw a parsing error
            throw new ParseException(current, NonTerminal.IfTail, Arrays.asList(
                LexicalUnit.END,
                LexicalUnit.ELSE
            ));
    }
}

  /**
 * Treats a <Cond> (conditional expression) at the top of the stack.
 * 
 * Tries to apply rule [25] <Cond> → <SimpleCond> <Cond'>
 * 
 * @return a string with a <Cond> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String cond() throws IOException, ParseException {
    // Switch statement to handle different possible starting tokens for a condition.
    switch (current.getType()) {
        
        // If the current token is one of the valid types that can start a condition
        // (MINUS, LPAREN, PIPE, VARNAME, NUMBER), we proceed with parsing.
        case MINUS:
        case LPAREN:
        case PIPE:
        case VARNAME:
        case NUMBER:
            // Rule [25] applies: <Cond> → <SimpleCond> <Cond'>
            // First, we parse the <SimpleCond> part (a basic condition).
            // Then, we process any additional conditions with <Cond'>.
            return simpleCond() + condPrime(); // Concatenate the results of simpleCond() and condPrime()

        // If the current token is not a valid start for a condition, throw a parse exception.
        // The exception includes the expected token types that can follow in a conditional expression.
        default:
            throw new ParseException(current, NonTerminal.ExprArith, Arrays.asList(
                LexicalUnit.MINUS,
                LexicalUnit.LPAREN,
                LexicalUnit.PIPE,
                LexicalUnit.VARNAME,
                LexicalUnit.NUMBER
            ));
    }
}

    
  /**
 * Treats a <Cond'> (conditional continuation) at the top of the stack.
 * 
 * Tries to apply one of the rules:
 * <ul>
 *   <li>[26] <Cond'> → -> <Cond></li>
 *   <li>[27] <Cond'> → ε (epsilon)</li>
 * </ul>
 * 
 * @return a string with a <Cond'> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String condPrime() throws IOException, ParseException {
    // Switch statement to determine what action to take based on the current token type.
    switch (current.getType()) {
        
        // [26] Rule: <Cond'> → -> <Cond>
        // If the current token is "IMPLIES" (->), it indicates that the condition is followed by another condition.
        case IMPLIES:
            match(LexicalUnit.IMPLIES); // Match the "IMPLIES" token
            String code = cond(); // Parse the next condition (<Cond>) after the "IMPLIES" operator.
            return code; // Return the code for the new condition.

        // [27] Rule: <Cond'> → ε (epsilon) - This means that <Cond'> can be empty, ending the condition.
        // If the current token is either PIPE (|) or RBRACK (]), we terminate the condition.
        case PIPE:
        case RBRACK:
            return ""; // Return an empty string to indicate that there is no further condition.

        // If the current token is not expected (neither "IMPLIES", "PIPE", nor "RBRACK"),
        // throw a ParseException to signal a syntax error.
        default:
            throw new ParseException(current, NonTerminal.CondPrime, Arrays.asList(
                LexicalUnit.IMPLIES, // Expecting "IMPLIES"
                LexicalUnit.PIPE,    // Or "PIPE"
                LexicalUnit.RBRACK  // Or "RBRACK"
            ));
    }
}

    /**
 * Treats a <SimpleCond> at the top of the stack.
 * 
 * Tries to apply one of the rules:
 * <ul>
 *   <li>[28] <SimpleCond> → | <Cond> |</li>
 *   <li>[29] <SimpleCond> → <ExprArith> <Comp> <ExprArith></li>
 * </ul>
 * 
 * @return a string with a <SimpleCond> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String simpleCond() throws IOException, ParseException {
    switch (current.getType()) {
        
        // [28] Rule: <SimpleCond> → | <Cond> |
        // If the current token is "PIPE" (|), it indicates that we are parsing a condition of the form: | <Cond> |
        case PIPE:
            match(LexicalUnit.PIPE);  // Match the opening "PIPE" (|)
            String code = cond();     // Parse the inner condition (<Cond>) recursively.
            match(LexicalUnit.PIPE);  // Match the closing "PIPE" (|)
            return code;              // Return the parsed code for the condition inside the pipes.

        // [29] Rule: <SimpleCond> → <ExprArith> <Comp> <ExprArith>
        // If the current token is a valid arithmetic expression (MINUS, LPAREN, VARNAME, or NUMBER),
        // this means we are parsing a comparison between two arithmetic expressions.
        case MINUS:
        case LPAREN:
        case VARNAME:
        case NUMBER:
            // First, parse the first arithmetic expression (<ExprArith>).
            code = exprArith();
            int nbrLastExp = this.lineNumber - 1;  // Store the line number of the last expression.
            
            // Then, parse the comparison operator (<Comp>).
            String comp = compOp();
            
            // Next, parse the second arithmetic expression (<ExprArith>).
            code += exprArith();
            
            // Generate the code for the comparison (icmp), using the two previously parsed expressions.
            code += "  %" + this.lineNumber + " = icmp " + comp + " i32 %" + nbrLastExp + ", %" + (this.lineNumber - 1) + "\n";
            this.lineNumber++;  // Increment the line number.
            
            return code;  // Return the generated code for the comparison operation.
            
        // If the current token does not match any of the expected types, throw a ParseException.
        default:
            throw new ParseException(current, NonTerminal.SimpleCond, Arrays.asList(
                LexicalUnit.PIPE,    // Expecting "|"
                LexicalUnit.MINUS,   // Or "MINUS"
                LexicalUnit.LPAREN,  // Or "LPAREN"
                LexicalUnit.VARNAME, // Or "VARNAME"
                LexicalUnit.NUMBER   // Or "NUMBER"
            ));
    }
}
/**
 * Treats a <Comp> at the top of the stack.
 * 
 * Tries to apply one of the rules:
 * <ul>
 *   <li>[30] <Comp> → ==</li>
 *   <li>[31] <Comp> → <=</li>
 *   <li>[32] <Comp> → <</li>
 * </ul>
 * 
 * @return a string with a <Comp> non-terminal at the root, representing the comparison operator in LLVM IR.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String compOp() throws IOException, ParseException {
    switch (current.getType()) {
        
        // [30] Rule: <Comp> → == (Equality comparison)
        case EQUAL:
            match(LexicalUnit.EQUAL);  // Match the equality operator "=="
            return "eq";  // In LLVM IR, the comparison operator for equality is "eq".
        
        // [31] Rule: <Comp> → <= (Less than or equal comparison)
        case SMALEQ:
            match(LexicalUnit.SMALEQ);  // Match the "less than or equal to" operator (<=)
            return "sle";  // In LLVM IR, the comparison operator for "less than or equal" is "sle".
        
        // [32] Rule: <Comp> → < (Less than comparison)
        case SMALLER:
            match(LexicalUnit.SMALLER);  // Match the "less than" operator ("<")
            return "slt";  // In LLVM IR, the comparison operator for "less than" is "slt".
        
        // If the current token is not one of the expected comparison operators, throw a ParseException.
        default:
            throw new ParseException(current, NonTerminal.Comp, Arrays.asList(
                LexicalUnit.EQUAL,   // Expected token: equality operator (==)
                LexicalUnit.SMALEQ,  // Expected token: less than or equal to (<=)
                LexicalUnit.SMALLER  // Expected token: less than (<)
            ));
    }
}

   /**
 * Treats a <While> at the top of the stack.
 * 
 * Tries to apply rule [33] <While> → WHILE { <Cond> } REPEAT <Code> END.
 * 
 * @return a string with a <While> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String whileExpr() throws IOException, ParseException {
    // Initialize the code string
    String code = "";

    // Match the WHILE keyword
    match(LexicalUnit.WHILE);

    // Generate a unique label number for the while loop
    this.whileNumber += 2;
    int currentWhile = this.whileNumber;

    // Add a label to jump to the loop entry
    code += "  br label %while" + (currentWhile - 2) + "\n";
    code += " while" + (currentWhile - 2) + ":\n";

    // Match the opening brace for the condition
    match(LexicalUnit.LBRACK);

    // Parse the loop condition
    String cond = cond();
    code += cond;

    // Generate code for conditional branching (check the condition)
    String exitLabel = "exitWhile" + (currentWhile - 1);
    code += "  br i1 %" + (this.lineNumber - 1) + ", label %while" + (currentWhile - 1) + ", label %" + exitLabel + "\n";
    code += " while" + (currentWhile - 1) + ":\n";

    // Match the closing brace for the condition
    match(LexicalUnit.RBRACK);

    // Match the REPEAT keyword
    match(LexicalUnit.REPEAT);

    // Parse the loop body (code inside the loop)
    String loopBody = code();
    code += loopBody;

    // Add a branch to go back to the condition check if the loop is not done
    code += "  br label %while" + (currentWhile - 2) + "\n";

    // Add the exit label (when the condition is false)
    code += " " + exitLabel + ":\n";

    // Match the END keyword to complete the while loop
    match(LexicalUnit.END);

    // Return the generated code
    return code;
}
/**
 * Treats a <For> at the top of the stack.
 * 
 * Tries to apply rule [49] <For> → for [VarName] from <ExprArith> to <ExprArith> do <Instruction>.
 * 
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String forExpr() throws IOException, ParseException {
    // Initialize the code string
    String code = "";

    // Match the FOR keyword
    match(LexicalUnit.FOR);

    // Parse the loop variable name
    String varName = (String) current.getValue();
    match(LexicalUnit.VARNAME);

    // Match the ASSIGN keyword (assign value to the loop variable)
    match(LexicalUnit.ASSIGN);

    // Parse the loop's starting value
    int nbr1 = (int) current.getValue();
    match(LexicalUnit.NUMBER);

    // Match the SMALLER keyword
    match(LexicalUnit.SMALLER);

    // Parse the loop's upper bound value
    int nbr2 = (int) current.getValue();
    match(LexicalUnit.NUMBER);

    // Match the DO keyword to start the loop body
    match(LexicalUnit.DO);

    // Add the variable to the symbol table
    addVariable(varName, LexicalUnit.VARNAME);

    // Initialize the loop variable
    code += "  %" + this.lineNumber + " = add i32 0, " + nbr1 + "\n";
    code += "  store i32 %" + this.lineNumber + ", i32* %" + varName + "\n";
    this.lineNumber++;

    // Generate labels for the loop
    int currentFor = this.forNumber;
    this.forNumber += 3;
    code += "  br label %for" + currentFor + "\n";
    code += " for" + currentFor + ":\n";

    // Load the current value of the loop variable and compare it with the upper bound
    code += "  %" + this.lineNumber + " = load i32, i32* %" + varName + "\n";
    this.lineNumber++;
    code += "  %" + this.lineNumber + " = icmp slt i32 %" + (this.lineNumber - 1) + ", " + nbr2 + "\n";
    this.lineNumber++;

    // Conditional branch: If the condition is true, jump to the loop body; otherwise, exit
    code += "  br i1 %" + (this.lineNumber - 1) + ", label %for" + (currentFor + 1) + ", label %for" + (currentFor + 2) + "\n";
    code += " for" + (currentFor + 1) + ":\n";

    // Parse the loop body (code inside the loop)
    String body = code();
    code += body;

    // Increment the loop variable and store the new value
    code += "  %" + this.lineNumber + " = load i32, i32* %" + varName + "\n";
    this.lineNumber++;
    code += "  %" + this.lineNumber + " = add i32 %" + (this.lineNumber - 1) + ", 1\n";
    this.lineNumber++;
    code += "  store i32 %" + (this.lineNumber - 1) + ", i32* %" + varName + "\n";

    // Jump back to the condition check
    code += "  br label %for" + currentFor + "\n";

    // Exit point of the loop
    code += " for" + (currentFor + 2) + ":\n";

    // Match the END keyword to complete the for loop
    match(LexicalUnit.END);

    // Return the generated code
    return code;
}


   /**
 * Treats a <Output> at the top of the stack.
 * 
 * Tries to apply rule [34] <Output> → OUT([VarName]).
 * 
 * @return a string with a <Output> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String outputExpr() throws IOException, ParseException {
    // [34] <Output>  ->  OUT([VarName])
    match(LexicalUnit.OUTPUT); // Match 'OUT' keyword
    match(LexicalUnit.LPAREN); // Match '('
    
    addoutput(); // Handle output (specific implementation of this is unknown)

    // Get the variable name
    String varName = (String) current.getValue();
    match(LexicalUnit.VARNAME); // Match variable name

    // Ensure that the variable was declared
    if (!this.varList.contains(varName)) {
        throw new Error("Variable " + varName + " was not declared before use.");
    }

    match(LexicalUnit.RPAREN); // Match ')'

    this.lineNumber++; // Increment line number for the next instruction

    // Generate LLVM IR code for printing the variable
    return "  %" + (this.lineNumber - 1) + " = load i32, i32* %" + varName + "\n" 
         + "  call void @printf(i32 %" + (this.lineNumber - 1) + ")\n";
}
/**
 * Treats a <Input> at the top of the stack.
 * 
 * Tries to apply rule [35] <Input> → IN([VarName]).
 * 
 * @return a string with a <Input> non-terminal at the root.
 * @throws IOException in case the lexing fails (syntax error).
 * @throws ParseException in case the parsing fails (syntax error).
 */
private String inputExpr() throws IOException, ParseException {
    // [35] <Input>  ->  IN([VarName])
    addinput(); // Handle input (specific implementation of this is unknown)
    
    match(LexicalUnit.INPUT);   // Match 'IN' keyword
    match(LexicalUnit.LPAREN);  // Match '('
    
    // Get the variable name
    String varName = (String) current.getValue();
    String code = "";
    match(LexicalUnit.VARNAME); // Match the variable name

    addVariable(varName, LexicalUnit.VARNAME);  // Add the variable to the list of declared variables

    // Generate LLVM IR code for input operation
    code += "  %" + this.lineNumber + " = call i32 @input()\n";  // Call input function to get an integer
    code += "  store i32 %" + this.lineNumber + ", i32* %" + varName + "\n";  // Store the input value in the variable

    this.lineNumber++;  // Increment line number for the next instruction
    
    match(LexicalUnit.RPAREN);  // Match ')'
    return code;  // Return the generated LLVM IR code
}


}
